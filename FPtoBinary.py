# -*- coding: utf-8 -*-
"""Untitled55.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MR_n5PoKjSvQDooP0soUOHJJEkQq4nJX
"""

class BinaryValue:
    def __init__(self, binstr, n_bits):
        self.binstr = binstr.zfill(n_bits)
        self.n_bits = n_bits

    def __str__(self):
        return self.binstr

    def __repr__(self):
        return f"BinaryValue({self.binstr}, n_bits={self.n_bits})"


def float2twos(x: float, quotient: tuple) -> BinaryValue:
    bit_width, frac_width = quotient
    scaled = abs(int(round(x * (1 << frac_width))))

    if scaled > (1 << (bit_width - 1)) - 1:
        max_positive = ((1 << (bit_width - 1)) - 1) / (1 << frac_width)
        min_negative = -(1 << (bit_width - 1)) / (1 << frac_width)
        raise ValueError(f"float2twos: {x} too large, "
                         f"must be between {min_negative} and {max_positive}")

    bin_value = bin(scaled)[2:].zfill(bit_width)

    if x < 0:
        inverted = ''.join('1' if bit == '0' else '0' for bit in bin_value)
        twos_comp = bin(int(inverted, 2) + 1)[2:].zfill(bit_width)
        return BinaryValue(twos_comp, n_bits=bit_width)

    return BinaryValue(bin_value, n_bits=bit_width)


def twos2float(x: BinaryValue, quotient: tuple) -> float:
    bit_width, frac_width = quotient
    binstr = x.binstr

    if binstr[0] == '1':  # negative
        num = int(binstr, 2)
        num = -((1 << bit_width) - num)
    else:
        num = int(binstr, 2)

    return num / (1 << frac_width)


def convert_file(input_filename, output_filename, quotient):
    bit_width, frac_width = quotient
    with open(input_filename, 'r') as f_in, open(output_filename, 'w') as f_out:
        for line_num, line in enumerate(f_in, 1):
            line = line.strip()
            if not line:
                continue  # skip empty lines
            try:
                val = float(line)
                bv = float2twos(val, quotient)
                f_out.write(str(bv) + '\n')
            except ValueError as e:
                print(f"Skipping line {line_num} (value '{line}'): {e}")


def convert_file_with_float_back(input_filename, output_filename_bin, output_filename_float, quotient):
    bit_width, frac_width = quotient
    with open(input_filename, 'r') as f_in, \
         open(output_filename_bin, 'w') as f_bin_out, \
         open(output_filename_float, 'w') as f_float_out:

        for line_num, line in enumerate(f_in, 1):
            line = line.strip()
            if not line:
                continue
            try:
                val = float(line)
                bv = float2twos(val, quotient)
                f_bin_out.write(str(bv) + '\n')

                # Convert back to float to check correctness
                val_back = twos2float(bv, quotient)
                f_float_out.write(f"{val_back}\n")

            except ValueError as e:
                print(f"Skipping line {line_num} (value '{line}'): {e}")


if __name__ == "__main__":
    bit_width = int(input("Enter total bit width: "))
    frac_width = int(input("Enter fractional bit width: "))
    quotient = (bit_width, frac_width)

    choice = input("Choose mode: (1) single input, (2) file input: ")

    if choice == "1":
        x = float(input("Enter a floating point number: "))
        bv = float2twos(x, quotient)
        print(f"\nTwo's Complement Binary: {bv}")
        print(f"Converted back to float: {twos2float(bv, quotient)}")

    elif choice == "2":
        input_file = input("Enter input filename (with floats): ")
        output_file_bin = input("Enter output filename for binary results: ")
        output_file_float = input("Enter output filename for converted back floats (optional, press Enter to skip): ")

        if output_file_float.strip() == "":
            convert_file(input_file, output_file_bin, quotient)
            print(f"Conversion done. Binary output saved in '{output_file_bin}'")
        else:
            convert_file_with_float_back(input_file, output_file_bin, output_file_float, quotient)
            print(f"Conversion done. Binary output saved in '{output_file_bin}', floats saved in '{output_file_float}'")

    else:
        print("Invalid choice.")